import * as fs from "node:fs";
import path from "node:path";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { GoogleAIFileManager } from "@google/generative-ai/server";
import {
  Failure,
  Ok,
  type ReviewRequest,
  type ReviewResponse,
} from "@vslint/shared";
import { getLogger } from "../logger";

const TMPFILE_DIR = "./review_images/";

const getGenAIClient = (modelConfig: ReviewRequest["model"]) => {
  const apiKey = modelConfig.key;
  if (!apiKey) return Failure(new Error("GEMINI_API_KEY not set"));
  const genAI = new GoogleGenerativeAI(apiKey);
  const fileManager = new GoogleAIFileManager(apiKey);
  return Ok({ genAI, fileManager });
};

const getFileManager = (modelConfig: ReviewRequest["model"]) => {
  const { response: clients, error: clientError } = getGenAIClient(modelConfig);
  if (clientError) return Failure(clientError);
  return Ok(clients.fileManager);
};

const getModel = (renderRequest: Pick<ReviewRequest, "model" | "rules">) => {
  const systemInstructions = `
  You are an AI assistant trained to review website designs and provide actionable feedback. You take in an image (generated by rendering HTML) and then review it according to the set of rules below. If the test fails the rule and is problematic, return true. If the test fails the rule, return false.
  
  ${renderRequest.rules.map((rule) => `${rule.ruleid}: ${rule.description}`).join("\n")}

  You also add a final field called "explanation" that gives a summary of the most important rules that failed. If no rules failed this should be null.
  `.trim();
  const { response: clients, error: genAIError } = getGenAIClient(
    renderRequest.model,
  );
  if (genAIError) return Failure(genAIError);
  return Ok(
    clients.genAI.getGenerativeModel({
      model: renderRequest.model.modelName,
      systemInstruction: systemInstructions,
    }),
  );
};

const uploadToGemini = async (
  modelConfig: ReviewRequest["model"],
  imageBuffer: Buffer,
  mimeType: "image/png",
) => {
  const fileName = `${new Date().getTime()}.png`;
  const tmpFile = path.join(TMPFILE_DIR, fileName);
  if (!fs.existsSync(TMPFILE_DIR)) fs.mkdirSync(TMPFILE_DIR);
  fs.writeFileSync(tmpFile, imageBuffer);
  getLogger().debug(`Wrote tmpfile to ${tmpFile}`);

  const { response: fileManager, error: fileManagerError } =
    getFileManager(modelConfig);
  if (fileManagerError) {
    return Failure(fileManagerError);
  }
  const uploadResult = await fileManager.uploadFile(tmpFile, {
    mimeType,
    displayName: fileName,
  });
  fs.unlinkSync(tmpFile);
  const file = uploadResult.file;
  return Ok(file);
};

const CHAT_SESSSION_CONFIG = {
  temperature: 0,
  topP: 0.95,
  topK: 64,
  maxOutputTokens: 1000,
  responseMimeType: "application/json",
};

export const runGeminiReview = async (
  renderRequest: Pick<ReviewRequest, "model" | "rules">,
  imageBuffer: Buffer,
  mimeType: "image/png",
) => {
  const { response: uploadedImage, error: uploadError } = await uploadToGemini(
    renderRequest.model,
    imageBuffer,
    mimeType,
  );
  if (uploadError) return Failure(uploadError);

  const { response: model, error: modelError } = getModel(renderRequest);
  if (modelError) return Failure(modelError);

  const chatSession = model.startChat({
    generationConfig: CHAT_SESSSION_CONFIG,
    history: [
      {
        role: "user",
        parts: [
          {
            fileData: {
              mimeType: uploadedImage.mimeType,
              fileUri: uploadedImage.uri,
            },
          },
        ],
      },
    ],
  });

  try {
    const result = await chatSession.sendMessage(
      "Return design review results in JSON format.",
    );
    const reviewResult = result.response.text();
    const parsedResult = JSON.parse(reviewResult);
    const violations: ReviewResponse["violations"] = {};
    let explanation = "No design violations detected in component.";
    for (const rule of renderRequest.rules) {
      const ruleResult = parsedResult[rule.ruleid];
      violations[rule.ruleid] = {
        fail: ruleResult,
        rule: rule.description,
      };
      if (ruleResult) {
        explanation = `Design violations detected in component: ${rule.description}`;
      }
    }
    return Ok({ violations, explanation });
  } catch (err) {
    return Failure(err);
  }
};
