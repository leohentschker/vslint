import * as fs from "node:fs";
import path from "node:path";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { GoogleAIFileManager } from "@google/generative-ai/server";
import { Failure, Ok } from "../types";
import { logger } from "../logger";

const TMPFILE_DIR = "./review_images/";

const getGenAIClient = () => {
	const apiKey = process.env.GEMINI_API_KEY;
	if (!apiKey) return Failure(new Error("GEMINI_API_KEY not set"));
	const genAI = new GoogleGenerativeAI(apiKey);
	const fileManager = new GoogleAIFileManager(apiKey);
	return Ok({ genAI, fileManager });
};

const getFileManager = () => {
	const { response: clients, error: clientError } = getGenAIClient();
	if (clientError) return Failure(clientError);
	return Ok(clients.fileManager);
};

const getModel = () => {
	const systemInstructions = `
  You are an AI assistant trained to review website designs and provide actionable feedback. You take in an image (generated by rendering HTML) and then review it according to the set of rules below. If the test fails the rule and is problematic, return true. If the test fails the rule, return false.
  
  text_too_wide: If any line of text contains more than 75 characters, mark it as true; otherwise, mark it as false.
  text_has_typos: If there are absolutely any spelling or grammatical errors, or content is in the wrong tense, mark it as true; otherwise, mark it as false. Be very harsh.
  text_is_coherent: If text for grouped elements isn't following the same grammatical style or structure, mark it as true; otherwise, mark it as false
  text_too_small: Check if the text is easily readable. If the text size is too small, mark it as true; otherwise, mark it as false.
	hierarchy_through_font_weight: Check to see if hierarchy is managed via font weight not via font size. 

  You also add a final field called "explanation" that gives a summary of the most important rules that failed. If no rules failed this should be null.
  `.trim();
	const modelName = "gemini-1.5-flash";
	const { response: clients, error: genAIError } = getGenAIClient();
	if (genAIError) return Failure(genAIError);
	return Ok(
		clients.genAI.getGenerativeModel({
			model: modelName,
			systemInstruction: systemInstructions,
		}),
	);
};

const uploadToGemini = async (imageBuffer: Buffer, mimeType: "image/png") => {
	const fileName = `${new Date().getTime()}.png`;
	const tmpFile = path.join(TMPFILE_DIR, fileName);
	if (!fs.existsSync(TMPFILE_DIR)) fs.mkdirSync(TMPFILE_DIR);
	fs.writeFileSync(tmpFile, imageBuffer);
	logger.debug(`Wrote tmpfile to ${tmpFile}`);

	const { response: fileManager, error: fileManagerError } = getFileManager();
	if (fileManagerError) {
		return Failure(fileManagerError);
	}
	const uploadResult = await fileManager.uploadFile(tmpFile, {
		mimeType,
		displayName: fileName,
	});
	fs.unlinkSync(tmpFile);
	const file = uploadResult.file;
	return Ok(file);
};

const CHAT_SESSSION_CONFIG = {
	temperature: 0,
	topP: 0.95,
	topK: 64,
	maxOutputTokens: 1000,
	responseMimeType: "application/json",
};

export const runReview = async (imageBuffer: Buffer, mimeType: "image/png") => {
	const { response: uploadedImage, error: uploadError } = await uploadToGemini(
		imageBuffer,
		mimeType,
	);
	if (uploadError) return Failure(uploadError);

	const { response: model, error: modelError } = getModel();
	if (modelError) return Failure(modelError);

	const chatSession = model.startChat({
		generationConfig: CHAT_SESSSION_CONFIG,
		history: [
			{
				role: "user",
				parts: [
					{
						fileData: {
							mimeType: uploadedImage.mimeType,
							fileUri: uploadedImage.uri,
						},
					},
				],
			},
		],
	});

	try {
		const result = await chatSession.sendMessage(
			"Return design review results in JSON format.",
		);
		const reviewResult = result.response.text();
		return Ok(JSON.parse(reviewResult));
	} catch (err) {
		return Failure(err);
	}
};
