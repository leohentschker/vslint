import * as fs from "node:fs";
import path from "node:path";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { GoogleAIFileManager } from "@google/generative-ai/server";
import { logger } from "../logger";
import { Failure, Ok, type RenderRequest } from "../types";

const TMPFILE_DIR = "./review_images/";

const getGenAIClient = (modelConfig: RenderRequest["model"]) => {
	const apiKey = modelConfig.key;
	if (!apiKey) return Failure(new Error("GEMINI_API_KEY not set"));
	const genAI = new GoogleGenerativeAI(apiKey);
	const fileManager = new GoogleAIFileManager(apiKey);
	return Ok({ genAI, fileManager });
};

const getFileManager = (modelConfig: RenderRequest["model"]) => {
	const { response: clients, error: clientError } = getGenAIClient(modelConfig);
	if (clientError) return Failure(clientError);
	return Ok(clients.fileManager);
};

const getModel = (renderRequest: RenderRequest) => {
	const systemInstructions = `
  You are an AI assistant trained to review website designs and provide actionable feedback. You take in an image (generated by rendering HTML) and then review it according to the set of rules below. If the test fails the rule and is problematic, return true. If the test fails the rule, return false.
  
	${renderRequest.rules.map((rule) => `${rule.ruleid}: ${rule.description}`).join("\n")}

  You also add a final field called "explanation" that gives a summary of the most important rules that failed. If no rules failed this should be null.
  `.trim();
	const { response: clients, error: genAIError } = getGenAIClient(
		renderRequest.model,
	);
	if (genAIError) return Failure(genAIError);
	return Ok(
		clients.genAI.getGenerativeModel({
			model: renderRequest.model.modelName,
			systemInstruction: systemInstructions,
		}),
	);
};

const uploadToGemini = async (
	modelConfig: RenderRequest["model"],
	imageBuffer: Buffer,
	mimeType: "image/png",
) => {
	const fileName = `${new Date().getTime()}.png`;
	const tmpFile = path.join(TMPFILE_DIR, fileName);
	if (!fs.existsSync(TMPFILE_DIR)) fs.mkdirSync(TMPFILE_DIR);
	fs.writeFileSync(tmpFile, imageBuffer);
	logger.debug(`Wrote tmpfile to ${tmpFile}`);

	const { response: fileManager, error: fileManagerError } =
		getFileManager(modelConfig);
	if (fileManagerError) {
		return Failure(fileManagerError);
	}
	const uploadResult = await fileManager.uploadFile(tmpFile, {
		mimeType,
		displayName: fileName,
	});
	fs.unlinkSync(tmpFile);
	const file = uploadResult.file;
	return Ok(file);
};

const CHAT_SESSSION_CONFIG = {
	temperature: 0,
	topP: 0.95,
	topK: 64,
	maxOutputTokens: 1000,
	responseMimeType: "application/json",
};

export const runReview = async (
	renderRequest: RenderRequest,
	imageBuffer: Buffer,
	mimeType: "image/png",
) => {
	const { response: uploadedImage, error: uploadError } = await uploadToGemini(
		renderRequest.model,
		imageBuffer,
		mimeType,
	);
	if (uploadError) return Failure(uploadError);

	const { response: model, error: modelError } = getModel(renderRequest);
	if (modelError) return Failure(modelError);

	const chatSession = model.startChat({
		generationConfig: CHAT_SESSSION_CONFIG,
		history: [
			{
				role: "user",
				parts: [
					{
						fileData: {
							mimeType: uploadedImage.mimeType,
							fileUri: uploadedImage.uri,
						},
					},
				],
			},
		],
	});

	try {
		const result = await chatSession.sendMessage(
			"Return design review results in JSON format.",
		);
		const reviewResult = result.response.text();
		return Ok(JSON.parse(reviewResult));
	} catch (err) {
		return Failure(err);
	}
};
